ctrl + r ----> reverse search to get command interctively from history
ctrl + w  ------> to delete word by word in terminal what u entered
ctrl + a  ----->begining of  command
ctrl + e   ------> end of entire command
!begining words of history commands---> !hi or !ifc
!21 ----> used to execute 21th cammand from history
man <command> to get manual page of command *****
info <command>  to get full information a
<command> --help 
bin---> system user executable binary program files simply  (commands).no need of special privileges to execute them by normal user
boot---->kernel location and booting configuration file are available
dev---> hard disk devices that are currently detected  by os
etc---> all cofiguration files of softwares installed
lib---->esential library files and kernel modules .. different programs uses  these libaries to add more features instead of 
         everytime writing same libraries  making shared library for all the program when ever they need too utilize it 
         to add those features
         kernel modules-->which supports for the feature 
home ---> provide for normal user home directory
root -->home directory of root user
media ----> used to mount removable media like pendrive and cod rom some dostributions may uses this location as default mount for removable 
            media some disributions not
mnt ---> used for mounting the external hard drive (mounting: process of mapping the hard drive to file systrem hyrarchy of linux system to 
         use the that hard drive as storage 
opt ---> used for installing the user specific external applications 
sbin ---> system administator(super user) executable binary program (commands) files located in this location ..system administator commands require special previleges to execute by normal user
          like iptables and shutdown apt usradd usrmod usrdel systemctl service reboot mkfs init fdisk yum
srv ---> in olden days people are using this directory for web hosting file like for  html and css files now a days using var/www/html
tmp ---> has special featured directory in which who ever the created only that user can delete and modify files other user cant except 
         root user it has sticky bit nature 

usr---> the location where man pages of commands available and also we can create our own custom commands and place inthis location
var --> where all the log files are available ex system logs ,apache, mysql, remote connection logs ,ssh ,boot logs
proc--> location where the the currently executable processes are available actually the programs are from the harddisk loaded into RAM memory (fast retrival) and then exectuted by processor
        means accessing the proc directory means we are actually loooking into   RAM MEMORY storage where the currently executable processes are available
       process: the piece of code currently executed by cpu which is loaded into RAM
       software: set of program file written to achieve required functionality
       program: piece of code 

working with environment variable:
=================================
env ----> command is used to list all environment variables
set up environment variable:
COLLEGE=mgit  ----> this is type varaible declaration will not carry env to any other processes
export OFFICE=FOURNINE  ---> this type of variable declaration will carry env to any other processes
echo $OFFICE  ---> TO print varibale
but if the server get restarted these envs gets wanished to prevent these envs we neeed to place them in a file file and when the server gets restarted
and shell starts the script will execute and set as envs
add variable in ~/config file like NAME=sravan and add the source in ~/.bashrc  filr(source config)


vi editor:
===========
G or shift+g--->end of text in the file
gg ----------> begining of the line
ALT+ right arrow----> end of line
ALT+ left arrow ----->begining of the line
/<required word or search word>  ---->to search words in command mode
dd---> delete the line 5dd -->delete  lines
yy --> copy the line   
p---> paste  the line
yw---> copy the word
===========================

du -sh <directory name> ---> check actual size of  the directory with all its content
stat filename or directory name

working with DNS:
=================
ping--->pocket internet grooper
send pockets of data to a server and receive pockets

/etc/hosts  -->file which is having list of mappings of ipaddresses and name of the servers
/etc/resolve.conf --> this file having the nameserver entry (dns server) ...first preferances to the hosts file and dns system
/etc/nsswitch.conf --> dns query methodology preference by default first preferences to the hosts file and dns server which is having entry 
                      in /etc/resolve.conf we can change the preference by changing the hosts section in the file

dig-->stands for domain information groper used to debugg the dns system 
ex: dig  www.yahoo.com +trace -->trace the dns query system
    dig www.yahoo.com -->  show A record
    dig www.yahoo.com +short -->shows the A record in short form
   dig www.yahoo.com ANY --> show all available records associated to domain
   dig www.yahoo.com MX --> shows mail server record
    
      
nslookup -->stands for  name server lookup for  debuugging of dns  ...name to ip or viceversa
 ex : nslookup  yahoo.com
      nslookup -type=any yahoo.com
      nslookup -type=a sravan.com
      nslookup -type=soa sravan.com
      nslookup -type=ns sravan.com
      nslookup -type=mx sravan.com
      nslookup -type=txt sravan.com
        
reverse ns lookup --> nslookup <ipaddress>
                         
tracepath google.com ----> it show  tracking path of request
 
working with dns query system:
==============================
dns server has cache for domain ip addresses.this cache can live up to ttl value mentioned ttl means time to live 
client -->/etc/hosts-->/etc/resolve.conf(dns server address)-->dns server
the preference of this dns query is configured in a file /etc/nsswitch.conf
we can change the routing of dns query preference either first goes to local host file or directly to the dns server which is configured in /etc/resolve.conf
active directory or LDAP(light weight directory active protocal) it means instead of having user authentication credentials in local, having in the central database ..so when user wants log in into system it first search in the local as preferences given /etc/ns.switch.conf then goes to central database  ..we can chage the preferences in this file to modify the preference..  
 nsswitch.conf-->nameserviceswitch.conf

 types of records:
 =================
 A    --> A record, point to the IPV4 address for a domain 
 AAA  --> AAA record points to IPV6 addresses for a domain.
 CNAME -->  "canonical name"—record points a domain name (an alias) to another domain. In a CNAME record, the alias doesn't point to an IP address. And the domain name that the alias points to is the canonical name.
             For ex the subdomain ng.example.com can point to example.com using CNAME. Here example.com points to the actual IP address using an A record.
nsrecord:  A nameserver (NS) record specifies the authoritative DNS server for a domain. 
MX record: A mail exchange (MX) record, is a DNS record type that shows where emails for a domain should be routed to
 
other record types:
-----------------
SRV record   ---> Using this DNS record type, it's possible to store the IP address and port for specific services.
PTR record: A pointer (PTR) record provides a domain name for reverse lookup. It's the opposite of an A record as it provides the domain name linked to an IP address instead of the IP address for a domain.
SOA record: SOA stands for "start of authority." It's an important DNS record type that stores admin information about a domain. This information includes the email address of the admin and when the domain was last updated.
DNAME: The full meaning of DNAME is "delegation name." This record type works very similarly to CNAME; however, it points all the subdomains for the alias to the canonical domain name.


working with storage,partitions and formating of a disk:
 =========================================================

 The MBR, boot sectors and partition table :
 -----------------------------------------
The information about how a hard disk has been partitioned is stored in its first sector (that is, the first sector of the first track on the first disk surface). 
The first sector is the master boot record (MBR) of the disk; this is the sector that the BIOS reads in and starts when the machine is first booted.
The master boot record contains a small program that reads the partition table, checks which partition is active (that is, marked bootable), and reads the first sector of that partition, the partition's boot sector (the MBR is also a boot sector, but it has a special status and therefore a special name). 
This boot sector contains another small program that reads the first part of the operating system stored on that partition (assuming it is bootable), and then starts it
 
 storage types :
 ================
 1)DAS (Directly Attached Storage) ---> like USB
 2)NAS (Network Attached Storage)----> like NFS
 3)SAN (Storage Area Network) --->

 partition types:
 ---------------
 1)primary partition --> used to boot the os limited 
 2)extended partitions --> diretcly not used but used to host logical partitions
 3)logical partitions  --> 



 lsblk--> list the all blocks attached to server
 blkid  <devicename>--> to see the device id  and type of file system software
 df -h --> check datailed view of disk total,free,used space 
 fdisk -l --> to check all the devices and all partitions in indivisual disk
 fdisk -n --> new partition
 fdisk -m -->help
 
 mkfs -t <filesystemtype> <devicename> --> to make file system on top of harddrive
 mount <devicename> <mount point> --> to mount device 
 umount <devicename> 
 
 if we mount manually using these commands then when the server gets restarted then mount points of devices wanished automatic mounting will not happen
 to get auto mount when the restarted we have configure the device block and mount point in the /etc/fstab file
 ex:
    	UUID=<DEVICEID> <MOUNTPOINT> <TYPEOFFILESYSTEM> defaults,nofails
      
working with filesystem:
========================
ext2: when file is corrupted while entering the file system when system crashes will not identifise the where actually correpted 
ext3: The main benefit of ext3 is that it allows journaling
Journaling has a dedicated area in the file system, where all the changes are tracked. 
When the system crashes, the possibility of file system corruption is less because of journaling.

/etc/rs.local :-->the file script which execute is final stage of booting  (mount /dev/xvda /sravan)
/etc/fstab : --> the file script which is execute at initial stage of booting  

/etc/fstab fields: 1)uuid or name of disk or label
        2)mountpoint
        3)type of filesystem
        4)default or noexec ,ro,noauto,nosuid,rw,nouser -->additional specfications for disk moutnig (mounting options)
        5)0  ---> dump back up
        6)0   ---> check file system while booting 

LABEL=MY_BACKUP /mount/point           ext4    defaults        0       2
or
/dev/sda5  /mount/point           ext4    defaults        0       2
10.10.0.10:/backups /var/backups  nfs      defaults    0       0

e2label /dev/sda5 "MY_BACKUP" --> to create label
mount -t ext4 -o ro /dev/xvda /mount/point -->mount as read only
mount -a -->make sure that all the devices configured inthe /etc/fstab is mounted


Journaling has a dedicated area in the file system, where all the changes are tracked. 
When the system crashes, the possibility of file system corruption is less because of journaling.

 
 working with softlink and hard link:
 =====================================
 
shortcuts: links-->1)soft link and 2)hard link 
soft link -->used to create a short cut of the file and directory which is buried in the long path directory.this soft link has different inode numbers for source file and destination file if source file is deleted then from destination file data can't be accessed 
file refers to another file ,file and directories and file systems can be linked
command : ln -s <sourcefile> <destinationfile>

hard link--> it is also similar to the soft link but the difference is source and destination files have different inode number associated and also if source file is deleted then also the from destination file the data can be accessed
             multiple names reffered to same inode number and folders and devices can't be hard linked 
command: ln <sourcefile> <destinationfile>

load on the server: the no of proceesses currently waiting to be executed by cpu because 1 cpu can only execute 1 process at a time ..more the processes are waiting to be executed means server is loaded heavily and lesser the no of processes are waiting means lighter load on the server 
command: uptime --> used to know the when the server got up and averege load on the server

system accounts types:
----------------------
1) normal user(uid>1000){/home/$USER}
2) root user (uid&gid=0)
3) system user(1<uid<1000)
4) service user {/var/lib/name of user}

all user related information present in /etc/passwd file 
it has several fields  1)username 2)password field 3)uid (user idenfication number) 4)gid (group identification number) 5)comment field about user 6) user's home directory 7)shell
all the user's password related information present in the /etc/shadow file .actually users password is stored in the system using some alogarithems using one way hashing method 
it consist of 8 feilds they are 1)username 2)hashed password 3)no of days passed since 1 jan 1980 the password was changed 4)the no days required to change password succcessively5)no of days after which the password is expired 6)the no of days before which the password expiry warning is prompted 7)no of days after which the account the is disable 8) the days after which the the account is expired
all the groups related inforation stored in the /etc/group file.and the user who are members of which groups information also present

users---> /etc/passwd
groups---> /etc/groups
passwords----> /etc/shadow

working with useradd command:
=============================

useradd sravan
useradd -d /opt/sravn sravan --to specify the users home directory
useradd -u <userid>  -g <existing group id> username
useradd -G groupname username--> user is created and user become a meber of that group
useradd -m <username> assign home directory to user
useradd -s </bin/sh or /bin/bash or /sbin/nologin> <username> assign shell  to user

working with usermod command:
=============================

usermod -l <oldusername> <newusername>  ---> to change username
usermod -g <existing groupname> <username> --> to change primary group of a user
usermod -d <homedirectory> <username>  --> to change the home directory of user
usermod -u <userid>  <username>--> to change the userid of a user
usermod -e <expirydate> <username>  --> to set expiry date for the user
usermod -c <comment for user> <username> --> to write comment about user 
usermod -L <username> --> to lock the user
usermod -U <username> --> to unlock the user 
usermod -p <password> <username> --> to set password unencrypted form
usermod -s </bin/sh or /bin/bash or /sbin/nologin> <username> -->to set the shell for the user
groupadd <groupname> --> to add the group
groupdel <groupname>  --> to delete the group
userdel <username>   --> to delete user
groups <username>  --> to check the groups associated to the user
id <username> --> to check the user info uid,gid,groups associated to the user 
usermod -a -G <groupname> <username> ---> to add user in to a existing group
gpasswd  <groupname>  ---> Set password for group
gpasswd -d <groupname>  <username> --> to remove a user from group

normal user is not having the root user previlleges to get root user previlleges the user group is added in 
/etc/sudoers  file  

1st method:
==========
entry in the /etc/sudoers  file 
------------------------------------

username ALL=(ALL:ALL) ALL --> the user can get root previleges to execute /sbin directory commands then prompt for password
ex: sravan  ALL=(ALL:ALL) ALL  --> prompt password
    arun    ALL=(ALL:ALL) NOPASSWD:ALL  ---> no password required
    john ALL=(root) /bin/systemctl restart NetworkManager --> specfic user and specific command
    username ALL=(ALL) NOPASSWD: /usr/bin/apt-get , !/sbin/shutdown ---> no password prompt muliple commands , not command
  
to get only specific commands:

ALL=(ALL:ALL) 
Allow members of group sudo to execute any command
--------------------------------------------------

%groupname ALL=(ALL:ALL) ALL   --> prompt password
%sudo	ALL=(ALL:ALL) ALL  --> example

2nd method:
===========
create group and  add  group in the sudoers file 
then add the user to that group

sravan  ALL=(ALL:ALL) ALL 
1)The first field indicates the username that the rule will apply to 
2)The first “ALL” indicates that this rule applies to any hosts by default  to local
3)second “ALL” indicates that the root user can run commands as all users.(User:Group)
4)third “ALL” indicates that the root user can run commands as all groups.(User:Group)
5)"NOPASSWORD" indicates that no to prompt for self password to authenticate
6)The last “ALL” indicates these rules apply to all commands.

working with file permissions and ownership:
===========================================

read=r=4, write=w=2 ,ecxecute=x=1 rw=4 rwx=7
 chmod 700 <filename> --> to change the file permission
 chmod -R 644 <directoryname> ---> to change the file recurrsively
 chown <user:group> <filename>  --> to change ownership of file
 chown -R <user.group> <directoryname>  --> to change ownership of file
   
 special permissions:
 --------------------
  set uid(+s)(4): special set of permission which enables the executable permissions to the all users as its owner
  examples: chmod 4755 [filename] or chmod u+s [filename]
 ----------
/bin/chfn
/bin/umount
/bin/fusermount
/bin/sudo
/bin/newgrp
/bin/pkexec
/bin/passwd
/bin/mount
/bin/su
/bin/gpasswd
/bin/chsh

set gid(+s)(2): special set of permission which enables the executable permissions to al users as its group
examples:  chmod 2755 [directory name] or chmod g+s [dir name]
---------
  /usr/bin/expiry
/ssh-agent
./mlocate
./wall
./chage
./dotlockfile
./mlock
./crontab
./bsd-write

sticky bit(+t)(1): Only the owner (and root) of a file can remove the file within that directory. A common example of this is the /tmp directory
example: chmod 1777 [dir name] or chmod +t [dir name]

  SUID = 4
  SGID = 2
  Sticky = 1
  
 working with storage,partitions and formating of a disk:
 =========================================================

 The MBR, boot sectors and partition table :
 -----------------------------------------
The information about how a hard disk has been partitioned is stored in its first sector (that is, the first sector of the first track on the first disk surface). 
The first sector is the master boot record (MBR) of the disk; this is the sector that the BIOS reads in and starts when the machine is first booted.
The master boot record contains a small program that reads the partition table, checks which partition is active (that is, marked bootable), and reads the first sector of that partition, the partition's boot sector (the MBR is also a boot sector, but it has a special status and therefore a special name). 
This boot sector contains another small program that reads the first part of the operating system stored on that partition (assuming it is bootable), and then starts it
 
 lsblk--> list the all blocks attached to server
 blkid  <devicename>--> to see the device id  and type of file system software
 df -h --> check datailed view of disk total,free,used space 
 fdisk -l --> to check all the devices and all partitions in indivisual disk
 fdisk -n --> new partition
 fdisk -m -->help



 
 mkfs -t <filesystemtype> <devicename> --> to make file system on top of harddrive
 mount <devicename> <mount point> --> to mount device 
 umount <devicename> 
 
 if we mount manually using these commands then when the server gets restarted then mount points of devices wanished automatic mounting will not happen
 to get auto mount when the restarted we have configure the device block and mount point in the /etc/fstab file
 ex:
    	UUID=<DEVICEID> <MOUNTPOINT> <TYPEOFFILESYSTEM> defaults,nofails
    	
 working with rpm packages:-
 =============================  	
    	
  rpm-->redhat package manager -->86*32--> 32 bit operating system which can support the 32 bits of data processing at a time by proccessor noarch-->mean operating system architecture indepedent
  rpm -qa --> query all installed packages
  rpm -ivh <package name>  ---> install the package (i=install  v=verbose h=hash tags output )
  rpm -uvh <package name>   ---> update the package  (u=update)
  rpm -e <package name>  ---> remove the package (e=erase)
  rpm -qf <config file location> --> to query the particular file belongings to which package
  rpm -q <package name> --> to check particular file installed or not

  redhat package manage does not resolve dependencies issues by itself so then yum is introduced to avoid this problem 
  it is having repository files containg the romete repository urls 

  working with yum package in redhat:
==================================
Yellowdog Update, Modified (YUM) is a program that manages installation, updates and removal for Red Hat package manager (RPM) systems

 yum list --installed   ---> used to list the all installed packages
 yum info <package name>   --used to find detailed information about that package
 yum list  --> show the all the available packages and installed packages
 yum install <package name> --> to install the package
 yum remove <package name>  --> to remove package
 yum update <package name>  --> to update the package
 
 list List package names from repositories
 -----------------------------------------
yum list available   ---> List all available packages
yum list installed  --->  List all installed packages
yum list all  -->  List installed and available packages

update Update one or all packages on your system
-------------------------------------------------
yum update  ---> Update all packages with available updates
yum update httpd  ---> Update the httpd package (if available)
 
 working with debian packages:
 ===============================
 dpkg -l ---> to query list all packages installed
 dpkg -l <package name>    ---> to query particular package installed or not 
 dpkg -i <package name>    ---> to install dpkg package 
 dpkg -r <package name>    ----> to remove dpkg package
 dpkg -s <package name>    ----> to check status whether installed or not or any issue

working with apt-debian packages:
===================================
Advanced package tool(APT), is a free-software user interface that works with core libraries to handle the installation and removal of software on Debian, and Debian-based Linux distributions.
  
 the configuration file of apt package is /etc/apt/sources.list --> all the repository url's present in this file

apt:
---
 apt is user friendly and easily understandable output 
  
  apt update  --> update apt repo
  apt upgrade  ---> update all installed packages
  apt upgrade <package name> ---> update particular package installed 
  apt install <package name>   --> install package
  apt remove <package name>    --> remove package
  apt search <package name>   ---> to search package is available or not in apt repo
  apt list --installed   --> list all installed packages 
  apt list --installed <package name>  --to see particular package installed or not

apt-get :
---------

 apt-cache pkgnames --> to list all available package name
 apt-get update --> used to update the repository and cache to updated versions
 apt-get upgrade   ---> used to update all the installed packages in the server
 apt-get dist-upgrade  --> to update the linux distribution
 apt-get upgrade <packageName> --only-upgrade   ---> upgrade the specific package installed
 apt-get install <packagename> --> to install packages
 apt-get remove <packagename>  --> to remove the package but it doesnot remove the configuration file which are came with package
 apt-get purge <packagename>   --> removes the packages, and also removes any configuration files related to the packages.
 apt-get autoremove -->Sometimes the packages which are automatically installed to satisfy the dependencies of other packages, are no longer needed then autoremove command is used to remove     				these kind of packages.
apt show <package name>  --> to display details of a package. Part of this information is dependencies and you can see it in the line starting with Depends.including control file
apt-cache depends <package_name>  ---> show dependencies of that package

apt-get remove --purge <package name> --> remove package and configuration files in single shot

apt-cache search <package name> --> shows description about package

  
working with tcp and udp protocols and ports:
===============================================
tcp and udp are the data transfer or communication channels through which tha data transfer or communication between the the servers happens over the internet
tcp: it is connection based protocol ,in this type of  protocol no loss of data pockets   
udp: it is a connection less protocol ,in this type there is chance of loss of data pockets

telnet:- used to test whether we are able connect to server through specific tcp port or not----it makes connection with target server
syntax:  telnet <domain name or ip address> <port>

nc -vz -u <domain name or ip address> <port>   ----> used to check the wether we able able to connect to speific udp protocol or not --- it just sends junk data to the target server
nc -l <port> ---> open port temporarly

working with iptables:
=========================

installing of iptables :  apt-get install iptables
types of tables in the iptables 

consist of INPUT,FORWARD,OUTPUT,PRE-ROUTING,POST-ROUTING chains
1)filter table   2)nat table  3)mangle table  4)raw table

iptables <options> 
-I — Inserts a rule in a chain at a point specified by a user-defined integer value. If no number is specified, iptables places the command at the top of the chain. 
-A — Appends the iptables rule to the end of the specified chain.
-D — Deletes a rule in a particular chain
-t — Specifies a table name. 
--dport — Specifies the destination port of the packet, using the service name, port number, or range of port numbers. The --destination-port match option is synonymous with --dport. 
--sport — Specifies the source port of the packet, using the service name, port number, or range of port numbers. The --source-port match option is synonymous with --sport. 
-n — Displays IP addresses and port numbers in numeric format, rather than the default hostname and network service format. 
-p — Sets the IP protocol for the rule, which can be either icmp, tcp, udp, or all,   (by default all)
-s to specify the source address
-d to specify the destination address
-j -used to specify the action ALLOW,REJECT,DROP,RETURN,QUEUE
REJECT — Sends an error packet back to the remote system and drops the packet. 
ACCEPT — Allows the packet to successfully move on to its destination or another chain.
DROP — Drops the packet without responding to the requester. The system that sent the packet is not notified of the failure. 

iptables -L -n -v  (L=list, n=resolves in numeric value ,v=verbose ) , default table is the filter tables ---> list the iptable rules
iptables -L -n -v --line-number   -->print with line numbers

                              {n=IP addresses and port numbers will be printed in numeric format.  By default, the program will try to display them as host names, network names, or services}

iptables -t filter -L ---> to list the filter table    (t= to specify type of table..filter table, nat table,mangle table,raw table)
iptabls -t nat -L  --> to listthe nat table
iptables -F  --> to delete all the rules (F=Flush)

iptables -A INPUT -p tcp/udp/icmp -j DROP ---> drop all the incoming traffic 
commonds:
--------
sudo iptables -A INPUT -p tcp -s 172.16.238.187 --dport 22 -j ACCEPT  --> allow ssh tcp protocal from 172.16.268.187 
sudo iptables -A INPUT -p tcp -s 172.16.238.187 --dport 80 -j ACCEPT  --> allow tcp protocal http  traffic from 172.16.268.187
sudo iptables -A INPUT -j DROP                                        --> to drop all traffic all types of protocals
iptables -A INPUT -p tcp -s 10.12.2.213 --dport 80 -j DROP ---> drop the tcp traffic which is comming on port 80 from 10.12.2.213
 generlized command :
 iptables -I/A <type of chain> -p <type of protocol> -s <source address> --dport <destination port> -j <action>
 
 routing
 --------
routing is the path of outbound request from the server ..how the network pockets are reaching to the destination path
route -n  ---> to check the route tables
traceroute <domain name>   ----> to trace the routing path for particular destination server
whois <ip address>  --> to know ip belongs to whom 

adding entry into route table
-----------------------------
route add -net <destination ip address> netmask 255.255.255.255 gw <gateway ip> --> to add route entry
route add -net <dest ip address> netmask 255.255.255.255 reject  ---> reject the outgoing request
route del -net <dest ip address> netmask 255.255.255.255 gw <gw ip> to delete the route entry
  
  NAT ---> Network address translation
  SNAT  ---> source network address translation   --->post-routing
  DNAT  ---> destination network address translatuion  ---> pre-routing --> 
  
  class 19:
  process monitoring and administration:
  ----------------------------------------
 ** kernel: it is a piece of code which manages the all the processes in the server .which is loaded firstly in to the memory and manages all the process to be executed 
   
**  when the server is booting up the first process which is triggered by kernel is init process.which is the one administartates and triggers the other process to be executed by server and this     process is the parent process for all the processes .becauuse of it is triggered firstly it gets pid number is 1 the pid number follws the order of the processes triggerred 

**the max no of process that the server can execute is actually presnet in /proc/sys/kernel/pid_max file , in fact we can change this max no of processes  by adding entry in /etc/sysctl.conf as kernel.pid_max = <max value>
 process: any program which currently executed by the system called as process
 
 virtual memroy : the combination of physical memory and the some of the spaces of hard disk which are allocated to use as memory called as virtual memory
  the process which  are rarely used are moved in to the hard disk memory
 load on the server : it is the no of processes waiting in the line to be proccessed by the processor which actually loaded into the memory for execution 
 it is actually a run queue..menas the no of proceesess are waiting in the queue to process it 
 
 ps -aux --->shows the all the processes running in the system with owner of process,process id,physical memory and virtual memory used by that process ,terminal id  
 ps -ef  ---> shows the extended view
 ps -p <pid> -o ppid=   ---> to know parent process id
 pstree ---> shows processes in tree structure manner 
 pstree -As <PID>   --> shows the specific process tree structure
 
 we terminate the process by sending the signals to the processs
 kill -l   ---> shows all the signals 
 kill -s <signal name> <pid>
 kill -<signal no> <pid>
 kill -9 <pid> forcefully killing the processs
 kill -2 <pid> terminating the process like manullay ctcl+c
 kill -15 <pid> sending signal as complete the process what ur doing and kill your self terminate
 
 Each process is assigned a process priority, which determines how much CPU or processor time is allocated to it for execution.
eventhough the kernel is the one which allocate the cpu time to the process in fact we can change the priority of process using nice command while execution or we can change the priority
 using renice command
 nice 10 <command>
 renice 10 -p <pid> existing process
 renice 15 -u <username> ,<another username>-g <groupname>,<another group name>    ----> to specify the process which is triggerrd by user and group have higher priority
 nice value ranges from -20 to 19,by default its value is zero
 
 ssh:
 ====
 ssh means secure socket shell this protocal is used to log in remotely ,rsa algorithem is used in ssh keys,it follows assymetric encryption
 generation of ssh keys:
 ssh-keygen  -------> used to to generate the keys keys are in encrypted format
 consist of 2 keys 1)public key 2) private key
 public key is with server binded to user and with private key we can decrypt the public key with private key
 
 setup of ssh configuration
 ===========================
 create a directory .ssh under home directory of user make directory permission as 700
 create a file named authorized_keys and copy public key into it and make file permission as 600
 
 ssh-copy-id username@ipadress --> used to copy the public remotely

remote log in :
-----------------
ssh -i <private key location> username@ipaddress
ssh -i <private key location> username@ipaddress -p <port number> --> if port forwarded

scp file1.txt username@hostname:/home/sravan   ---> to copy the (send) from local to romote server
scp username@hostname:~/file1.txt ./testdir/   ---> to copy from reomte to to local(download)

flags:
-r  --> copy directory
-p  --> preserve the ownership and permissions
-i  --> to specify identity file (private key location)
text processing tools:
=====================
1) tr
2)awk 
3)sed
4)grep

tr -d "charactor to delete"   ---> to delete the characters from output
tr 'replace chararcter' 'subitute character'
tr A-Z a-z    ---> to get output from capital to small
tr a-z A-Z    ---> TO GET OUTPUT FROM SMALL TO CAPTIAL

sort : used to get the content in ascending or descending order
sort <filename> to get the content in aseding order
sort -r <filename> to get the content in reverse order

grep: to to search the string in the content
grep <string> <filename> --> to search the string
grep -i <string> <filename>  --> to ingnore the case sensitive
grep -v <string> <filename>  --> to get the the output except the string line
grep -ir <string> <directory_name>  ---> to search the string recurssively
grep -w <string> <file name>  ---> to search a exact string 
 ^ --> begining of the line
 $  --> end of the line
 ^$ --> balnk lines
  *    The preceding item will be matched zero or more times.
 +    The preceding item will be matched one or more times.
 .    is used for periods instead of regular expression it matches everything as period 
 ?      The preceding item is optional and matched at most once

 special regular expresions: 
 =========================== 
 Basic vs Extended Regular Expressions
       In basic regular expressions the meta-characters ?, +, {, |, (, and )  lose  their  special
       meaning; instead use the backslashed versions \?, \+, \{, \|, \(, and \).

 grep "^rsra" <filename> --> shows the lines which begins with sra
 grep "kumar$" <filename>  --> shows the lins ends with kumar
 grep "^$" <filename> -->shows the blank lines
 .    is used for periods instead of regular expression it matches everything as period 
 grep -ri "c..t" /etc
 \.   is used to for exact matching of .  {backslash is used to tell dont consider this as period instead consider this as regulat expression}
 grep -ir "\."  /etc
 *    The preceding item will be matched zero or more times.
 grep -r "/.*/" /etc
 grep -r  instal* /etc
 grep -r "10*"  /etc/passwd

 +    The preceding item will be matched one or more times.
grep -r "instal\+" /etc
grep -r "10\+" /etc/passwd

?      The preceding item is optional and matched at most once
grep -r "port\?" /etc

{n}    The preceding item is matched exactly n times.
grep  "10\{2\}" /etc/passwd
{n,}   The preceding item is matched n or more times.
grep  "10\{2,\}" /etc/passwd
{,m}   The preceding item is matched at most m times.not more than m times
grep  "10\{,2\}" /etc/passwd
{n,m}  The preceding item is matched at least n times, but not more than m times.
grep  "10\{2,3\}" /etc/passwd

problem faced during grep is some special characters are allowed to do some funtionality like . + *  to say these funtionalities to work we need use 
escape character to make understand to the grep other wise it consider as noraml expression  but here we will get comfuse some times incase of . and * +
to avoid " . "funtionality we use escape charactor "\"  to make effect the * + funtionalities we need to use "\" so avoid this we are going for egrep or grep -E it automatically adjust

.   is used to for exact matching of .
grep -Eir "."  /etc

 +    The preceding item will be matched one or more times.
grep -Er "10+" /etc/ or egrep -r "10+" /etc/

?      The preceding item is optional and matched at most once
grep -Er "port?" /etc  or egrep -r "port?" /etc/

{n}    The preceding item is matched exactly n times.
grep -Er "10{2}" /etc

{n,}   The preceding item is matched n or more times.
grep -Er "10{2,}" /etc

{,m}   The preceding item is matched at most m times.not more than m times
grep -Er "10{,2}" /etc

{n,m}  The preceding item is matched at least n times, but not more than m times.
grep -Er "10{2,5}" /etc

  |  match one or other string
grep -Er "enabled|disabled" /etc/
grep -r "enabled?|disabled?" /etc/ 

To search range or set   [a-z] or [A-Z] or [0-9]
grep -iEr "c[ua]t" /etc
grep -iEr "/dev/[a-z]*" /etc
grep -iEr "/dev/[a-z]*[0-9]" /etc
grep -iEr "/dev/[a-z]*[0-9]?" /etc
grep -iEr "/dev/([a-z]*[0-9]?)*" /etc
grep -Er "/dev/([a-z]|[A-z])*([0-9]?)*" /etc

grep -Er "http[^s]" /etc         {http[^s]=http    not equal to https}


















 


linux booting process:
=====================
1)BIOS POST  
2)MBR
3)GRUB
4)kernel
5)init
6)RUNLEVEL

all the deamon processes started during boot are located in /etc/rcN.d. (Replace the N with the run-level)
ie ,rc0.d/ rc1.d/ rc2.d/ rc3.d/ rc4.d/ rc5.d/ rc6.d/ rcS.d/ 
In each run-level you will find a series of if links pointing to start-up scripts located in /etc/init.d. 
The names of these links all start as either K or S, followed by a number. 
If the name of the link starts with an S, then that indicates the service will be started when you go into that run level.ex:(S01dbus   )
If the name of the link starts with a K, the service will be killed because it is disabled with systemctl command (if running).ex:(K01speech-dispatcher   )
that is why rc.0 and rc.6 directory files starts with K because init 0 is poweroff and init 6 is reboot
there are 8 run levels means mode of server
/etc/rcN.d/* -->linked to-->/etc/init.d/binaryfile 

understand the service file defination and how it linked with booting:
=====================================================================
[Unit]
Description= description for service 

[Service]     --->define the service parameyers
Restart=always   -->action taken by systemd service when it is stopped
User=prometheus  ---> by default root is the owner of process if not specify so for security we allocate seperate user for processes owner
ExecStart=/usr/local/bin/alertmanager --config.file=/etc/alertmanager/alertmanager.yml --storage.path=/var/lib/alertmanager         
ExecReload=/bin/kill -HUP $MAINPID
TimeoutStopSec=20s
SendSIGKILL=no

[Install]              --> defines the when service is enabled in which run level it has to start ex: mutli-user.target   or graphical.target      
WantedBy=multi-user.target     --> if you enable service in rcN.d the file related to service in /etc/init.d/  is linked to respected runlevel defined in service file in install section
                                    the file name starts with S and followed by some sequence number then service name 
                                    if you disable the service that respected service /etc/init.d/service-file is linked to respected run level rcN.d and file name starts with K followed by 
                                    sequence number and the service name
                              
switch from run level 5 to 3 and check default run level:
========================================================
systemctl get-default  -->To view the default target
systemctl set-default multi-user.target    -->3 rd run level
systemctl set-default 
systemctl isolate multi-user.target   --> switch to multi-user.target
systemctl isolate graphical.target    --> switch to graphical.target


Run level 0 is matched by poweroff.target (and runlevel0.target is a symbolic link to poweroff.target).
Run level 1 is matched by rescue.target (and runlevel1.target is a symbolic link to rescue.target).
Run level 3 is emulated by multi-user.target (and runlevel3.target is a symbolic link to multi-user.target).
Run level 5 is emulated by graphical.target (and runlevel5.target is a symbolic link to graphical.target).
Run level 6 is emulated by reboot.target (and runlevel6.target is a symbolic link to reboot.target).
Emergency is matched by emergency.target.


RUNLEVEL:
========
0)[ init 0 ]-POWEROFF
1)[ init 1 ]-sigle user mode with no network facility available
2)[ init 2 ]-Multiple user mode with no NFS(network file system).no network facility
            **{A Network File System (NFS) allows remote hosts to mount file systems over a network and interact with those file systems as though they are mounted locally. }
3)[ init 3 ]-Multiple user mode under the command line interface and not under the graphical user interface with  network
4)[ init 4]– User-definable.(some research purpose)
            **{ Reserved for a local configuration. Special tasks such as machine tool handling or lab equipment. May include windowing if the system manager configures it.}
            **Most systems still reserved level 4 for the system manager's use.
5)[ init 5 ]– Multiple user mode under GUI (graphical user interface) and this is the standard runlevel for most of the LINUX based systems.
6)[ init 6 ]– Reboot which is used to restart the system.  
7)[ init 7 ]-maintance mode 
  

 working with find & locate :
 ===========================
 find:
 -----
 find / -name tecmint.txt  ---> to find file named  tecmint.txt dir recurssively
 find / -iname tecmint.txt  --->to find file named  tecmint.txt dir recurssively ignore case sensitive
 find / -type d -name Tecmint   ---> to Find all directories whose name is Tecmint in / directory.
 find / -user root -name tecmint.txt  -->To find all or single files called tecmint.txt under / root directory of owner root.
 find /home -user tecmint  ---> To find all files that belong to user Tecmint under /home directory.
 find /home -group developer  -->To find all files that belong to the group Developer under /home directory.
 find /home -perm 555 
 find / -type f -name Tecmint  ---> to Find all files whose name is Tecmint in / directory.
 
 locate:
 ------
 locate sravan.txt  ----> to find file named  sravan.txt dir recurssively
 locate -i *.txt  ---> ignore case sensitive
 **Since locate command relies on a database called mlocate. 
   The said database needs to be updated regularly for the command utility to work
   efficiently,To update the mlocate database, you use a utility called updatedb. 
   It should be noted that you will need superuser privileges for this to work properly, 

sudo updatedb    ---->to update mlocate database

hack with grep:
---------------
grep -ir <string> <directory> to search a word in dir in any file recurssively
grep -ir listen /etc   ---> shows matched word and file name with full path of file  recurssivesly
grep -ir "error.$" /var/log  --> shows all words which ends with error  in /var/log
grep -ir "^grafana"  /var/log --> shows all words which starts with grafana  in /var/log


file compression and archival:
-----------------------------






IO Redirection:
----------------
>   ---> overwrites the content
>>  ---> appends the content
0 is stdin
1 is stdout
2 is stderr

This “ 1> ” operator is also used for redirecting standard output.

Redirect stdoutput  echo "hi sravan" > sravan.txt      --> overwrites data
Redirect stdout echo "hi sravan" >> sravan.txt         --> appends data

This “ 1> ” operator is also used for redirecting standard output.
echo "hi sravan" 1> sravan.txt

less < /etc/passwd same as less 0< /etc/passwd

Redirect  stderror cat srvan.txt 2> error.txt   --> overwrites err data
redirect  stderro cat srvan.txt 2>> error.txt   --> appends err data
not to print on terminal and not to redirect to file     cat srvan.txt 2>> /dev/null


tee command is used to redirect output to file as well as  print on the screen

echo "sravan is devops guys" | tee sravan.txt   
grep -ir listen /etc | tee err.txt

networking in linux:
===================
interfaces and switches and routes,route entry



https://youtu.be/TsKE50hf4PU  -->learn linux link
http error code 
client side errors and server side errors
logs errors --server side errors 
log rotation
top and htop and egrep
openssl
logical volumes
increase inodes in partition
lost aws ssh keys
while booting run a process  how to run a custom process

A process in running state means that it is running or it’s ready to run.

The process is in a sleeping state when it is waiting for a resource to be available.

A process in Interruptible sleep will wakeup to handle signals, whereas a process in Uninterruptible sleep will not.

A process enters a stopped state when it receives a stop signal.

Zombie state is when a process is dead but the entry for the process is still present in the table.

.htaccess
lukx software
how to set password protect file in linux
how to recover a keys in linux if u lost keys --ami or mount another server root
how to take backup etcd and run backup etcd as cluster 
acls in linux ,helm charts in k8S
how to check the particular port connectivity to server --> telnet
what is connetction time out error? 
how to connect from windows clinets?ftp and nfs?

static ip connection conf and  ..
lvm partions and fstab types of file systems? permanent mount in windows and linux 
fstab grep egrep awk sed find
all log files ,booting issues ,kernel selcetion
,dhcp ,ftp,SAN,trouble shooting-->1)file system full2)file system ro 3)/boot full
4)kernel patch problem old kernel removel and set to old kernel5 )crontab all @reeboot @hourly
5)mail options  windows to linux file syatem share cifs
6)

6)how to mount logical vol /


/var/log/syslog
{
  weekly
  compress
  delaycompress
  rotate 10
  
}
error codes:
The following list describes the most common HTTP Error Codes and includes some possible resolutions.

400 Bad Request

This error indicates that the user's request contains incorrect syntax.

401 Unauthorized

This error indicates that the requested file requires authentication (a username and password).

403 Forbidden

This error indicates that the server will not allow the visitor to access the requested file. If a visitor receives this code unexpectedly, you should check the file's permission settings, or check whether the file has been protected.

404 Not Found

This error indicates that the server could not find the file that the visitor requested. This commonly occurs when a URL is mistyped.

5xx Errors

These errors are caused by the server being unable to fulfill an apparently valid request from a visitor. Often, you will need the help of a server administrator to investigate them.

It is also important to consider that quite often, a chain of servers is handling an HTTP request, so that it may not be your server that is returning the error.

500 Internal Server Error

This error indicates that the server has encountered an unexpected condition. This often occurs when an application request cannot be fulfilled due to the application being configured incorrectly on the server.

501 Not Implemented

This error indicates that the HTTP method sent by the client is not supported by the server. This is most often caused by the server being out of date. It is a very rare error and generally requires that the web server be updated.

502 Bad Gateway

This error is usually due to improperly configured proxy servers. However, the problem may also arise when there is poor IP communication between back—end computers, when the client's server is overloaded, or when a firewall is functioning improperly.

The first step in resolving the issue is to clear the client's cache. This action should result in a different proxy being used to resolve the web server's content.

503 Service Unavailable

This error occurs when the server is unable to handle requests due to a temporary overload or due to the server being temporarily closed for maintenance. The error indicates that the server will only temporarily be down. It is possible to receive other errors in place of 503.

Contact the server administrator if this problem persists.

504 Gateway Timeout

This error occurs when a server somewhere along the chain does not receive a timely response from a server further up the chain. The problem is caused entirely by slow communication between upstream computers.

To resolve this issue, contact the system administrator.

505 HTTP Version Not Supported

This error occurs when the server refuses to support the HTTP protocol that has been specified by the client computer. This can be caused by the protocol not being specified properly by the client computer; for example, if an invalid version number has been specified.

506 Variant Also Negotiates

This error indicates that the server is not properly configured. Contact the system administrator to resolve this issue.

507 Insufficient Storage

This error indicates that the server is out of free memory. This is most likely to occur when an application that is being requested cannot allocate the necessary system resources to run.

To resolve the issue, the server's hard disk may need to be cleaned of any unnecessary documents to free up more hard disk space, its memory may need to be expanded, or it may simply need to be restarted.

Contact the system administrator for more information regarding this error message.

509 Bandwidth Limit Exceeded

This error occurs when the bandwidth limit imposed by the system administrator has been reached. The only fix for this issue is to wait until the limit is reset in the following cycle.

Consult the system administrator for information about acquiring more bandwidth.

510 Not Extended

This error occurs when an extension attached to the HTTP request is not supported by the web server.

To resolve the issue, you may need to update the server. Consult the system administrator for more information.

session needed:
1)interfaces and ifconfig 
2)logs and which logs respect which log and how t find error and understanding of errors and also 
  how to debugg the error and slove it
3)error codes 


Awk sed grep egrep,find logrotate
 logrotate
 logical volumes
 Pipeline Shared Libraries 

 sessions needed from sampath anna:
 ==================================
 1) iptables live session and writing rules outbount , inbound , forward ,postroute and preroute
 2) live session on error codes and understanding the issues and trouble shooting
 3) interfaces in linux 
 4) booting and grub configuration in linux
 5)linux shortcut while using servers and hacks in linux while you are handling anything



linux linux foundation certified system administartor:
=====================================================
console  --->console appear in booting, after booting press ctrl + alt + F12 then gives virtual terminal 
in linux laptop if open terminal there we can fire commands 

hostnamectl
mandb
apropos ssh
mandb

pipeline {
  agent any
  environment {
    company = 'fournine'
    project = 'shipwire'
  }
  stages {
    stage('stage 1') {
      steps {
        sh 'echo $company'
        sh 'env | sort'
      }
    }
  }
}


run a job on multliple nodes simultlineously

JENKINS:
========
create view and adding jobs in it
trigger build in jenkins: using jenkins ui and api token authentication and jenkins cli
restart jenkins jenkinsurl/restart  --> free style job aborted and wont starts 
Restart using   jenkinsurl/safeRestart  --> waits until free style job completes and restarts
hint : any how pipeline project statrs again from where it stopped when it restarted so we need to only takecare of freestyle
rename job in jenkins
Integrating Dastardly with Jenkins  [not completed pls review]
Create Gitea Organization Folder job
create webhook
post sections in jenkins
environment variables 
credentials passed as enironment variables